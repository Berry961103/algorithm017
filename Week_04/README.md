### 寻找一个半有序数组 [4, 5, 6, 7, 0, 1, 2] 中间无序的地方 分析思路

    
        查找：
        基本查找:数组元素无序(从头找到尾)
        分析：
        * A:定义最大索引，最小索引
        * B:计算出中间索引
        * C:拿中间索引的值和要查找的值进行比较
        * 相等：就返回当前的中间索引
        * 不相等：
        * 大  左边找
        * 小  右边找
        * D:重新计算出中间索引
        * 大  左边找
        * max = mid - 1;
        * 小  右边找
        * min = mid + 1;
        * E:回到B
        */


### 860. 柠檬水找零
 
    贪心法：尽量将大面额的钱找给客户

    存储五元和十元的数量 five,ten=0，0
    for循环遍历，根据客户给的面额5，10，20来判断该找的价格
    if bill==5 则直接five++
    if bill==10 判断five>=1 则five--,ten+=1.否则 返回false
    if bill==20 
        if five >= 1 && ten >= 1 { // 有一张10块且一张五块。将面额大的找给客户
				five--
				ten--
			} else if five >= 3 { // 有三张5块的
				five -= 3
			} else {
				return false
			}

    时间复杂度:O(n)
    空间复杂度:O(1)

### 122. 买卖股票的最佳时机 II

    提醒，不要被官方题解误导了。只需要判断今天比昨天的价格高就卖出，

        if prices[i]-prices[i-1] > 0 { // 比较今天和昨天的价格,今天比昨天的价格高就卖出
			profit += prices[i] - prices[i-1] // 存储利润
		}

        循环的时候初始化i=1，

    时间复杂度O(n)
    空间复杂度O(1)    

### 455. 分发饼干

    先将饼干数和孩子数排序，而后定义i孩子吃上饼干的下标，j饼干数的下标，孩子吃上了i++,换下一个孩子吃下一块饼干j++

    时间复杂度主要在排序
    时间复杂度：O(NlogN)
    空间复杂度：O(1)

### 874. 模拟行走机器人

    题目讲的有点不清楚，看了题解才知道欧式距离。
    要先记录上右下左。
    用map存储障碍物
    1）如果是-1，向右
    curDir = (curDir+1) % 4
    2）如果是-2，向左
    curDir = (curDir+3) % 4

    可以试着算一算，比如-1时候， 1->2 / 2->3 / 3->4 / 4-> 1
    比较大小存储结果

    时间复杂度O(N)
    空间复杂度O(n)


### 127. 单词接龙

    广度优先搜索：套模板
    先遍历wordList 存为map，值为下标索引
    创建一个bool数组，确认对应的map下标是否被遍历过
    根据长度确定遍历次数
    后面基本就是BFS模板
    
    时间复杂度：O(NlogN)
    空间复杂度: O(N)


### 200. 岛屿数量
    深度优先搜索
    
    将相邻1的地方全部变为不为1的值，我这边为了好判断改为2
    两层for循环遍历行和列
    判断行中的列是水或者有相邻的陆地2是就跳出当前循环
    否则岛屿数量加1

    将当前不是水，或者已经未被标记的。行列传入dfs，将当前行转为2.每一行的每一列又判断他的上又下重复迭代至结束。注意防止越界

    时间复杂度：O(M*N)其中 M 和 N 分别为行数和列数。
    空间复杂度：O(1)

### 74. 搜索二维矩阵

    方法一：暴力搜索
        感觉暴力搜索比二分查找简单，而且应对这个题效率也不低

        时间复杂度: O(N*M)N行，M列
        空间复杂度：O(1)
    
    方法二：二分查找

    套二分查找模板，参考了一下优秀题解做了一些改进，依旧没到双一百

    时间复杂度 : O(log(m n))
    空间复杂度 : O(1)