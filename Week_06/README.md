### 总结
    动态规划本质就是数学归纳法寻找重复性。
    动态规划关键点： 动态规划和递归或分治没有根本上的区别，关键看有无最优子结构 共性：找到重复子问题 差异：最优子结构，中途可以淘汰次优解

    动态规划关键点： 1.最优子结构 2.存储中间状态 3.递推公式（状态转移方程或dp方程）

### 64. 最小路径和
 
    由题意知道只能往下或者往右，主要问题是在选择往下走还是往右走哪个路径小
    
#### 动态规划一：记录每一个格子的最小路径
    
    创建出一个同样长宽的格子为dp
    dp[0][0]=grid[0][0]
    第一行每一列的最小路径 dp[i][0]=dp[i-1][0]+grid[i][0]
    每一列第一行的最小路径 dp[0][i]=dp[0][i-1]+grid[0][i]
    剩余行列应该是：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]

    时间复杂度0(M*N) M是行，N是列
    空间复杂度O(M*N) M是行，N是列
    
#### 动态规划二：空间优化原地修改
    
    递推公式依旧一样

    如果是第一行不是第一列
        grid[i][j] += grid[i][j-1] 
    如果是第一列不是第一行
        grid[i][j] += grid[i-1][j] 
    不是第一行也不是第一列
        grid[i][j] += min(grid[i-1][j], grid[i][j-1]) 


    时间复杂度：0(M*N) M是行，N是列
    空间复杂度: O(1)，没有使用额外的空间 

### 91. 解码方法

    根据题意分析出，A-Z对应1-26个数字，也就是说传入的字符串只包含1-6这些数字字符串组成。
    dp int数组长度为s长度+1

    if s[i-1] != '0'
        dp[i]=dp[i-1]
    s[i-2]不等于1或者s[i-2]不等于2，且s[i-1]小于7
        dp[i] += dp[i-2]

    时间复杂度 O(N)
    空间复杂度 O(N)    

